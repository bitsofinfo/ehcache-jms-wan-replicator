<ehcache>

  	<diskStore path="user.home/ehcacheJMS"/>

    <!-- 
    	CustomizableJMSCacheManagerPeerProviderFactory:
    	
    	DC = data-center
    	
    	@see the OverridableActionCacheReplicatorFactory cacheEventListenerFactory declaration below
    	
    	We use this for DC2[cluster] -> DC1[cluster] communication of general Ehcache events notifications.
    	
    	The event notifications are triggered by the cacheEventListenerFactory[OverridableActionCacheReplicatorFactory]
    	declared later in this file. Ehcache events (PUTs, UPDATEs, REMOVEs etc) are all translated to REMOVES
    	with NO cache element 'value' for the DC->DC event notifications. Inter DC events only care about knowing 
    	what keys they need to purge and just let the next cache miss repopulate w/ latest data, 
    	hence why we convert all to REMOVEs. (This also saves on bandwith and is better for AWS SNS/SQS 
    	WAN processed events)
    	
	    The below peer provider factory is configured to use Nevado JMS bound to an AWS SNS topic, and SQS (get reply queue, which is NOT used)
	    for the replicated cache events. This configuration will decorate all OUTBOUND Messages with a property
	    called 'source_dc' = to whatever you specify via the -DdatacenterID=<val> System property.
	    
	    This configuration will IGNORE inbound events generated by local-DC peers sharing the same datacenterID
	    via the ignoreMessage* properties. (Local DC events will be handled by the RMICacheManagerPeerProviderFactory)
    	
     -->
    <cacheManagerPeerProviderFactory
       class="org.bitsofinfo.ehcache.jms.custom.CustomizableJMSCacheManagerPeerProviderFactory"
       				
       properties="initialContextFactoryName=org.bitsofinfo.ehcache.jms.custom.nevado.NevadoInitialContextFactory, 
       			   nevado.awsAccessKey=YOUR_AWS_ACCESS_KEY,
       			   nevado.awsSecretKey=YOUR_AWS_SECRET_KEY,
       			   nevado.SNSTopicName=ehcacheJMSTopic,
       			   nevado.SQSQueueName=ehcacheJMSReplyQueue,
       			   messageDecorations.source_dc=${datacenterID},
       			   messageDecorations.somethingElse=valueN,
       			   messageSelectorsSupported=false,
       			   messageSelector=notSupportedByNevado,
       			   ignoreMessagePropName=source_dc,
       			   ignoreMessagePropVal=${datacenterID}"
       propertySeparator="," />
       
       
       <!-- 
       		OPTIONAL, the next two listener/provider factories are just here as an example.
       		
       		RMICacheManagerPeerProviderFactory: Handles local DC replication of cache events. 
       		
       		http://ehcache.org/documentation/replication/rmi-replicated-caching
       		
       		RMICacheManagerPeerProviderFactory
        -->
       <cacheManagerPeerProviderFactory
			class="net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory"
			properties="peerDiscovery=manual,
						rmiUrls=//localhost:40001/testCache|//localhost:40002/testCache|//localhost:40003/testCache"/>
			
			
	    <!--  ditto above -->
		<cacheManagerPeerListenerFactory
			class="net.sf.ehcache.distribution.RMICacheManagerPeerListenerFactory"
			properties="hostName=localhost, port=40001,
			socketTimeoutMillis=2000"/>
       
       
       
       
     <!-- 
     
     	The test cache
     
      -->
	 <cache name="testCache"
	       maxElementsInMemory="1000"
	       maxElementsOnDisk="2000"
	       eternal="false"
	       overflowToDisk="false"
	       memoryStoreEvictionPolicy="LRU"
	       transactionalMode="off">
	       
	       
		  <!-- 
		  	   For replicating cache events (INCLUDING Element content) locally
		       to other peers within the same cluster operating out of the same DC
		   -->	      
		  <cacheEventListenerFactory
				class="net.sf.ehcache.distribution.RMICacheReplicatorFactory"
				properties="replicateAsynchronously=false, replicatePuts=true, replicateUpdates=true,
				replicateUpdatesViaCopy=false, replicateRemovals=true "/>
	       
	       <!-- 
		  	   For replicating cache events (EXCLUDING Element content) externally
		       to peers that live in other DC's that live across a WAN etc.
		       
		       This is configured to convert cache PUTs/UPDATEs (which would normally
		       include actual cached element data) to REMOVEs (no data). Receiving
		       DC's across WANs, will respond by just dumping these keys locally and
		       letting cache-misses repopulate from the underlying authoritative datasource
		   -->	
	       <cacheEventListenerFactory
			     class="org.bitsofinfo.ehcache.jms.custom.OverridableActionCacheReplicatorFactory"
			     properties="factoryClass=net.sf.ehcache.distribution.jms.JMSCacheReplicatorFactory,
			                  actionOverrideMap.put=remove,
			                  actionOverrideMap.update=remove,
			     		  replicateAsynchronously=true,
			                  replicatePuts=true,
			                  replicateUpdates=true,
			                  replicateUpdatesViaCopy=true,
			                  replicateRemovals=true,
			                  asynchronousReplicationIntervalMillis=1000"
			      propertySeparator=","/>
			      

  	</cache>
    
       
</ehcache>
