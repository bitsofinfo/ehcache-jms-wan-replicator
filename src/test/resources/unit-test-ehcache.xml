<ehcache name="${cacheManagerName}">

  	<diskStore path="user.home/ehcacheJMS"/>

    <!-- 
    	CustomizableJMSCacheManagerPeerProviderFactory:
    	
    	DC = data-center
    	
    	@see the OverridableActionCacheReplicatorFactory cacheEventListenerFactory declaration below
    	
    	We use this for DC2[cluster] -> DC1[cluster] communication of general Ehcache events notifications.
    	
    	The event notifications are triggered by the cacheEventListenerFactory[OverridableActionCacheReplicatorFactory]
    	declared later in this file. Ehcache events (PUTs, UPDATEs, REMOVEs etc) are all translated to REMOVES
    	with NO cache element 'value' for the DC->DC event notifications. Inter DC events only care about knowing 
    	what keys they need to purge and just let the next cache miss repopulate w/ latest data, 
    	hence why we convert all to REMOVEs. (This also saves on bandwith and is better for AWS SNS/SQS 
    	WAN processed events)
    	
	    The below peer provider factory is configured to use Nevado JMS bound to an AWS SNS topic, and SQS (get reply queue, which is NOT used)
	    for the replicated cache events. This configuration will decorate all OUTBOUND Messages with a property
	    called 'source_dc' = to whatever you specify via the -DdatacenterID=<val> System property. It will also
	    batch up qualifying events and send them every 30 seconds, OR when 200 events are batched, whicever comes first
	    
	    This configuration will IGNORE inbound events generated by local-DC peers sharing the same datacenterID
	    via the ignoreMessage* properties. (Local DC events will be handled by the RMICacheManagerPeerProviderFactory)
    	
     -->
    <cacheManagerPeerProviderFactory
       class="org.bitsofinfo.ehcache.jms.custom.CustomizableJMSCacheManagerPeerProviderFactory"
       				
       properties="initialContextFactoryName=org.bitsofinfo.ehcache.jms.custom.nevado.NevadoInitialContextFactory, 
      		 	   maxBatchQueuingTimeMS=10000,
				   maxEventsPerBatch=300,
       			   nevado.awsAccessKey=PUT_ACCESS_KEY_HERE,
       			   nevado.awsSecretKey=PUT_SECRET_KEY_HERE,
       			   nevado.SNSTopicName=ehcacheJMSTopic,
       			   nevado.SQSQueueName=ehcacheJMSReplyQueue,
       			   messageDecorations.source_dc=${datacenterID},
       			   messageDecorations.somethingElse=valueN,
       			   messageSelectorsSupported=false,
       			   messageSelector=notSupportedByNevado,
       			   ignoreMessagePropName=source_dc,
       			   ignoreMessagePropVal=${datacenterID}"
       propertySeparator="," />
       
       
   
       
     <!-- 
     	testCache1
      -->
	 <cache name="testCache1"
	       maxElementsInMemory="100000"
	       maxElementsOnDisk="50000"
	       eternal="false"
	       overflowToDisk="false"
	       memoryStoreEvictionPolicy="LRU"
	       transactionalMode="off">
	       

	       <!-- 
		  	   For replicating cache events (EXCLUDING Element content) externally
		       to peers that live in other DC's that live across a WAN etc.
		       
		       This is configured to force cache PUTS->noAction and UPDATEs (which would normally
		       include actual cached element data) to REMOVEs (no data) (same as replicateUpdatesViaCopy). 
		       Receiving DC's across WANs, will respond by just dumping these keys locally and
		       letting cache-misses repopulate from the underlying authoritative datasource
		   -->	
	       <cacheEventListenerFactory
			     class="org.bitsofinfo.ehcache.jms.custom.OverridableActionCacheReplicatorFactory"
			     properties="factoryClass=net.sf.ehcache.distribution.jms.JMSCacheReplicatorFactory,
			                  actionOverrideMap.put=nothing,
			                  actionOverrideMap.update=remove,
                              replicateAsynchronously=true,
			                  replicatePuts=true,
			                  replicateUpdates=true,
			                  replicateUpdatesViaCopy=true,
			                  replicateRemovals=true,
			                  asynchronousReplicationIntervalMillis=1000"
			      propertySeparator=","/>
			      

  	</cache>
  	
  	  <!-- 
     	testCache2
      -->
	 <cache name="testCache2"
	       maxElementsInMemory="100000"
	       maxElementsOnDisk="50000"
	       eternal="false"
	       overflowToDisk="false"
	       memoryStoreEvictionPolicy="LRU"
	       transactionalMode="off">
	       

	       <!-- 
		  	   For replicating cache events (EXCLUDING Element content) externally
		       to peers that live in other DC's that live across a WAN etc.
		       
		       This is configured to force cache PUTS->noAction and UPDATEs (which would normally
		       include actual cached element data) to REMOVEs (no data) (same as replicateUpdatesViaCopy). 
		       Receiving DC's across WANs, will respond by just dumping these keys locally and
		       letting cache-misses repopulate from the underlying authoritative datasource
		   -->	
	       <cacheEventListenerFactory
			     class="org.bitsofinfo.ehcache.jms.custom.OverridableActionCacheReplicatorFactory"
			     properties="factoryClass=net.sf.ehcache.distribution.jms.JMSCacheReplicatorFactory,
			                  actionOverrideMap.put=nothing,
			                  actionOverrideMap.update=remove,
                              replicateAsynchronously=true,
			                  replicatePuts=true,
			                  replicateUpdates=true,
			                  replicateUpdatesViaCopy=true,
			                  replicateRemovals=true,
			                  asynchronousReplicationIntervalMillis=1000"
			      propertySeparator=","/>
			      

  	</cache>
  	
  	  <!-- 
     	testCache3
      -->
	 <cache name="testCache3"
	       maxElementsInMemory="100000"
	       maxElementsOnDisk="50000"
	       eternal="false"
	       overflowToDisk="false"
	       memoryStoreEvictionPolicy="LRU"
	       transactionalMode="off">
	       

	       <!-- 
		  	   For replicating cache events (EXCLUDING Element content) externally
		       to peers that live in other DC's that live across a WAN etc.
		       
		       This is configured to force cache PUTS->noAction and UPDATEs (which would normally
		       include actual cached element data) to REMOVEs (no data) (same as replicateUpdatesViaCopy). 
		       Receiving DC's across WANs, will respond by just dumping these keys locally and
		       letting cache-misses repopulate from the underlying authoritative datasource
		   -->	
	       <cacheEventListenerFactory
			     class="org.bitsofinfo.ehcache.jms.custom.OverridableActionCacheReplicatorFactory"
			     properties="factoryClass=net.sf.ehcache.distribution.jms.JMSCacheReplicatorFactory,
			                  actionOverrideMap.put=nothing,
			                  actionOverrideMap.update=remove,
                              replicateAsynchronously=true,
			                  replicatePuts=true,
			                  replicateUpdates=true,
			                  replicateUpdatesViaCopy=true,
			                  replicateRemovals=true,
			                  asynchronousReplicationIntervalMillis=1000"
			      propertySeparator=","/>
			      

  	</cache>
    
       
</ehcache>
